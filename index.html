<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>üì∑ ‡§ï‡•à‡§Æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•ã (XML ‡§∏‡§ï‡•ç‡§∑‡§Æ)</title>
  <style>
    :root{--bg:#0b1020;--fg:#eaf2ff;--muted:#90a0c0;--accent:#5ac8fa;--danger:#ff5e57;--ok:#34c759}
    *{box-sizing:border-box} html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,"Helvetica Neue",Arial; overscroll-behavior: none;}
    .app{display:grid;grid-template-rows:auto 1fr auto;min-height:100%;}
    header,footer{backdrop-filter: blur(12px);-webkit-backdrop-filter: blur(12px);background:rgba(15,20,40,.7);padding:8px 12px;border-bottom:1px solid #1c223a}
    footer{border-top:1px solid #1c223a;border-bottom:none;}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button,select,input[type="range"]{appearance:none;-webkit-appearance:none;border:none;padding:10px 12px;border-radius:12px;background:#18203a;color:var(--fg);font-weight:600;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .primary{background:linear-gradient(180deg,#2c6dfd,#234fe0)}.danger{background:linear-gradient(180deg,#ff6a6a,#e64545)}.ok{background:linear-gradient(180deg,#36d27a,#29b365)}.ghost{background:transparent;border:1px solid #2a3558}.pill{border-radius:999px;padding:8px 14px}
    .stage{position:relative;background:#000;display:grid;place-items:center;overflow:hidden}
    video{max-width:100%;max-height:100vh;width:100%;height:100%;object-fit:contain;background:#000}
    canvas{position:absolute; inset:0; width:100%; height:100%; pointer-events:none;}
    .flash{position:absolute;inset:0;background:#fff;opacity:0;pointer-events:none;}.flash.show{opacity:0.85;animation:flash .25s ease-out forwards}
    @keyframes flash{to{opacity:0}}
    .overlay{position:absolute;inset:0;pointer-events:none}
    .grid{position:absolute;inset:0;background:repeating-linear-gradient(0deg,transparent 0,transparent calc(33.333% - .5px),rgba(255,255,255,.15) calc(33.333% - .5px),rgba(255,255,255,.15) calc(33.333% + .5px)),repeating-linear-gradient(90deg,transparent 0,transparent calc(33.333% - .5px),rgba(255,255,255,.15) calc(33.333% - .5px),rgba(255,255,255,.15) calc(33.333% + .5px));opacity:.75;display:none}.grid.on{display:block}
    .toolbar{position:absolute;inset-inline:0;bottom:16px;display:flex;justify-content:center;align-items:center;gap:12px;pointer-events:auto}
    .tb-btn{width:64px;height:64px;border-radius:50%;display:grid;place-items:center;font-weight:900}
    .gallery{display:flex;gap:8px;overflow:auto;padding:8px}
    .thumb{position:relative; width:72px;height:72px;border-radius:10px;overflow:hidden;border:1px solid #2a3558;flex:0 0 auto}.thumb img, .thumb video{width:100%;height:100%;object-fit:cover;display:block}
    .thumb .actions{position:absolute;inset:0;background:rgba(0,0,0,.5);display:flex;gap:4px;align-items:center;justify-content:center;opacity:0;transition:opacity .2s}.thumb:hover .actions{opacity:1}
    .thumb .actions a, .thumb .actions button{color:white;text-decoration:none;padding:4px;background:rgba(0,0,0,.5);border-radius:50%;border:none;cursor:pointer;font-size:18px;width:30px;height:30px;display:grid;place-items:center;}
    .panel{display:flex;gap:8px;align-items:center;flex-wrap:wrap}.hint{color:var(--muted);font-size:13px}.error{color:#ffd5d2}.spacer{flex:1}
    #recTimer{position:absolute;top:16px;left:50%;transform:translateX(-50%);background:rgba(255,94,87,.8);color:white;padding:4px 8px;border-radius:8px;font-weight:bold;display:none;}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="row">
        <strong>üì∑ ‡§ï‡•à‡§Æ‡§∞‡§æ ‡§™‡•ç‡§∞‡•ã</strong><span class="spacer"></span>
        <input type="file" id="xmlUpload" accept=".xml,application/xml" style="display:none;">
        <button id="btnUploadXml" class="ghost pill" title="XML ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç">‚öôÔ∏è XML</button>
        <button id="btnQR" class="ghost pill" title="QR ‡§∏‡•ç‡§ï‡•à‡§®‡§∞">üî≤</button>
        <button id="btnGrid" class="ghost pill" title="‡§ó‡•ç‡§∞‡§ø‡§°">#Ô∏è‚É£</button>
        <label class="ghost pill" title="‡§∞‡§ø‡§ú‡§º‡•â‡§≤‡•ç‡§Ø‡•Ç‡§∂‡§®">üîß<select id="selRes"><option value="1920x1080" selected>1080p</option><option value="1280x720">720p</option><option value="3840x2160">4K</option><option value="640x480">480p</option></select></label>
        <button id="btnStart" class="primary pill">‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç</button><button id="btnStop" class="danger pill" disabled>‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç</button>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="btnFlip" class="ghost pill" title="‡§ï‡•à‡§Æ‡§∞‡§æ ‡§¨‡§¶‡§≤‡•á‡§Ç">üîÑ</button>
        <button id="btnTorch" class="ghost pill" title="‡§ü‡•â‡§∞‡•ç‡§ö">üî¶</button>
        <label class="ghost pill" title="‡§ú‡§º‡•Ç‡§Æ">üîç <input id="rngZoom" type="range" min="1" max="1" step="0.1" value="1"></label>
        <span id="capabilities" class="hint"></span>
      </div>
    </header>
    <main class="stage" id="stage">
      <video id="vid" playsinline autoplay muted></video>
      <div class="overlay"><div id="grid" class="grid"></div><div id="flash" class="flash"></div><div id="recTimer">00:00</div></div>
      <canvas id="canv"></canvas>
    </main>
    <div class="toolbar">
      <select id="selTimer" class="ghost pill" style="pointer-events:auto">
        <option value="0" selected>‚è±Ô∏è ‡§ë‡§´</option><option value="3">3s</option><option value="5">5s</option>
      </select>
      <button id="btnSnap" class="tb-btn ok" title="‡§´‡•ã‡§ü‡•ã ‡§≤‡•á‡§Ç">‚óâ</button>
      <button id="btnRec" class="tb-btn primary" title="‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§°">‚è∫</button>
    </div>
    <footer>
      <div class="panel"><strong>üìÅ ‡§ó‡•à‡§≤‡§∞‡•Ä</strong><span class="spacer"></span><button id="btnClear" class="ghost pill" title="‡§ó‡•à‡§≤‡§∞‡•Ä ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç">üóëÔ∏è</button></div>
      <div id="gallery" class="gallery"></div>
      <div id="msg" class="hint"></div>
    </footer>
  </div>
<script>
(async function(){
  // Element Refs
  const $ = id => document.getElementById(id);
  const vid = $('vid'), canv = $('canv'), msg = $('msg'), flash = $('flash'), grid = $('grid'), gallery = $('gallery'), stage = $('stage');
  const btnStart = $('btnStart'), btnStop = $('btnStop'), btnFlip = $('btnFlip'), btnTorch = $('btnTorch'), btnSnap = $('btnSnap'), btnRec = $('btnRec'), btnGrid = $('btnGrid'), btnClear = $('btnClear'), btnQR = $('btnQR');
  const selRes = $('selRes'), selTimer = $('selTimer'), rngZoom = $('rngZoom');
  const btnUploadXml = $('btnUploadXml'), xmlUpload = $('xmlUpload');
  const capabilitiesEl = $('capabilities'), recTimerEl = $('recTimer');
  const ctx = canv.getContext('2d');

  // State
  let stream=null, track=null, usingFront=false, mediaRec=null, chunks=[], recInterval=null, qrScanner=null, isScanningQR=false;

  // Logging
  const log = t => msg.textContent = t;
  const error = e => { console.error(e); msg.innerHTML = `<span class="error">‚ö†Ô∏è ${e.name || 'Error'}: ${e.message}</span>`; }
  
  // Camera Control
  const startCamera = async () => {
    try {
      if (isScanningQR) await toggleQRScan();
      stopCamera();
      const [w, h] = selRes.value.split('x').map(Number);
      const constraints = { audio: false, video: { width: { ideal: w }, height: { ideal: h }, facingMode: usingFront ? 'user' : 'environment' } };
      log('üì¢ ‡§ï‡•à‡§Æ‡§∞‡§æ ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§Æ‡§æ‡§Å‡§ó‡•Ä ‡§ú‡§æ ‡§∞‡§π‡•Ä ‡§π‡•à‚Ä¶');
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      vid.srcObject = stream;
      track = stream.getVideoTracks()[0];
      setupCapabilities();
      setControlsState(true);
      log('‚úÖ ‡§ï‡•à‡§Æ‡§∞‡§æ ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à');
    } catch(e) { error(e); }
  };

  const stopCamera = () => {
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = track = null;
    setControlsState(false);
  };
  
  const setControlsState = (enabled) => {
    [btnStop, btnSnap, btnRec, btnFlip, btnTorch, rngZoom, btnQR, btnUploadXml].forEach(el => el.disabled = !enabled);
    btnStart.disabled = enabled;
    if (!enabled) { btnUploadXml.disabled = false; } // XML upload button should always be available initially
  };
  
  // Features
  const setupCapabilities = () => {
    const cap = track?.getCapabilities?.() || {};
    const settings = track?.getSettings?.() || {};
    rngZoom.min = cap.zoom?.min || 1; rngZoom.max = cap.zoom?.max || 1; rngZoom.step = cap.zoom?.step || 0.1; rngZoom.value = settings.zoom || 1;
    rngZoom.disabled = !cap.zoom; btnTorch.disabled = !cap.torch;
    let capText = `${settings.width||'-'}√ó${settings.height||'-'}`;
    if (cap.torch) capText += ' ¬∑ üî¶ ‡§ü‡•â‡§∞‡•ç‡§ö';
    if (cap.zoom) capText += ' ¬∑ üîç ‡§ú‡§º‡•Ç‡§Æ';
    capabilitiesEl.textContent = capText;
  };
  
  const snap = async () => {
    try {
      const delay = Number(selTimer.value);
      if(delay > 0) { log(`${delay}s ‡§Æ‡•á‡§Ç ‡§´‡•ã‡§ü‡•ã ‡§≤‡•Ä ‡§ú‡§æ‡§è‡§ó‡•Ä‚Ä¶`); await new Promise(r => setTimeout(r, delay*1000)); }
      if (!stream) throw new Error('‡§ï‡•à‡§Æ‡§∞‡§æ ‡§ö‡§æ‡§≤‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à');
      canv.width = vid.videoWidth; canv.height = vid.videoHeight;
      ctx.drawImage(vid, 0, 0, canv.width, canv.height);
      flash.classList.remove('show'); void flash.offsetWidth; flash.classList.add('show');
      const blob = await new Promise(r => canv.toBlob(r, 'image/jpeg', 0.9));
      const name = `photo_${new Date().toISOString().replace(/[:.]/g,'-')}.jpg`;
      const img = new Image(); img.src = URL.createObjectURL(blob);
      addToGallery(img, name, blob);
      log('üì∑ ‡§´‡•ã‡§ü‡•ã ‡§∏‡•á‡§µ ‡§π‡•ã ‡§ó‡§à‡•§');
    } catch(e) { error(e); }
  };
  
  const toggleRecord = () => {
    try {
      if (!stream) throw new Error('‡§ï‡•à‡§Æ‡§∞‡§æ ‡§ö‡§æ‡§≤‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à');
      if (mediaRec && mediaRec.state === 'recording') {
        mediaRec.stop();
        btnRec.textContent = '‚è∫'; btnRec.classList.remove('danger');
      } else {
        const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm';
        mediaRec = new MediaRecorder(stream, { mimeType: mime });
        chunks = [];
        mediaRec.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
        mediaRec.onstop = () => {
          clearInterval(recInterval); recTimerEl.style.display = 'none';
          const blob = new Blob(chunks, { type: mediaRec.mimeType });
          const v = document.createElement('video'); v.src = URL.createObjectURL(blob);
          v.controls = true; v.loop = true; v.muted = true;
          const name = `video_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;
          addToGallery(v, name, blob);
          log('üéûÔ∏è ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§∏‡•á‡§µ ‡§π‡•ã ‡§ó‡§Ø‡§æ‡•§');
        };
        mediaRec.start();
        btnRec.textContent = '‚èπ'; btnRec.classList.add('danger');
        let startTime = Date.now();
        recTimerEl.style.display = 'block';
        recInterval = setInterval(() => {
            const seconds = Math.floor((Date.now() - startTime) / 1000);
            recTimerEl.textContent = `${String(Math.floor(seconds / 60)).padStart(2, '0')}:${String(seconds % 60).padStart(2, '0')}`;
        }, 1000);
        log('üî¥ ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§°‡§ø‡§Ç‡§ó ‡§ö‡§æ‡§≤‡•Ç‚Ä¶');
      }
    } catch (e) { error(e); }
  };

  const toggleTorch = async () => { try { await track.applyConstraints({ advanced: [{ torch: !track.getSettings().torch }] }); } catch(e) { error(e); } };
  const setZoom = async (v) => { try { await track.applyConstraints({ advanced: [{ zoom: v }] }); log(`üîç ‡§ú‡§º‡•Ç‡§Æ: ${Number(v).toFixed(1)}√ó`);} catch(e) { error(e); } };
  
  const toggleQRScan = async () => {
    if(!('BarcodeDetector' in window)) return error(new Error('QR ‡§∏‡•ç‡§ï‡•à‡§®‡§∞ ‡§á‡§∏ ‡§¨‡•ç‡§∞‡§æ‡§â‡•õ‡§∞ ‡§™‡§∞ ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü‡•á‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§'));
    isScanningQR = !isScanningQR;
    btnQR.classList.toggle('primary', isScanningQR);
    if(isScanningQR) {
        if (!stream) await startCamera();
        qrScanner = new BarcodeDetector({ formats: ['qr_code', 'ean_13', 'codabar', 'code_128'] });
        scanQRCodes();
        log('üî≥ QR ‡§∏‡•ç‡§ï‡•à‡§®‡§∞ ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à...');
    } else {
        log('‚úÖ ‡§ï‡•à‡§Æ‡§∞‡§æ ‡§Æ‡•ã‡§°');
        ctx.clearRect(0,0,canv.width,canv.height);
    }
  };

  const scanQRCodes = async () => {
    if (!isScanningQR || !qrScanner) return;
    try {
        const barcodes = await qrScanner.detect(vid);
        canv.width = vid.videoWidth; canv.height = vid.videoHeight;
        ctx.clearRect(0,0,canv.width,canv.height);
        if (barcodes.length > 0) {
            barcodes.forEach(barcode => {
                log(`‡§∏‡•ç‡§ï‡•à‡§® ‡§π‡•Å‡§Ü: ${barcode.rawValue}`);
                const { x, y, width, height } = barcode.boundingBox;
                ctx.strokeStyle = '#34c759'; ctx.lineWidth = 4;
                ctx.strokeRect(x, y, width, height);
            });
        }
    } catch (e) { error(e); }
    requestAnimationFrame(scanQRCodes);
  };
  
  // XML Upload Handling
  const handleXmlUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const xmlText = e.target.result;
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
        if (xmlDoc.querySelector('parsererror')) throw new Error('‡§Ö‡§Æ‡§æ‡§®‡•ç‡§Ø XML ‡§´‡§º‡§æ‡§á‡§≤‡•§');
        applySettingsFromXml(xmlDoc);
      } catch (err) { error(err); }
    };
    reader.readAsText(file);
    xmlUpload.value = ''; // Reset file input
  };

  const applySettingsFromXml = (xmlDoc) => {
    const resolution = xmlDoc.querySelector('resolution')?.textContent;
    const zoom = xmlDoc.querySelector('zoom')?.textContent;
    const gridOn = xmlDoc.querySelector('grid')?.textContent === 'on';

    let restartRequired = false;
    log('‚öôÔ∏è XML ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§≤‡§æ‡§ó‡•Ç ‡§ï‡•Ä ‡§ú‡§æ ‡§∞‡§π‡•Ä ‡§π‡•à‡§Ç...');

    if (resolution && selRes.querySelector(`option[value="${resolution}"]`)) {
      if(selRes.value !== resolution) {
          selRes.value = resolution;
          restartRequired = true;
          log(`XML ‡§∏‡•á ‡§∞‡§ø‡§ú‡§º‡•â‡§≤‡•ç‡§Ø‡•Ç‡§∂‡§® ‡§∏‡•á‡§ü: ${resolution}`);
      }
    }
    
    if (grid.classList.contains('on') !== gridOn) {
        grid.classList.toggle('on', gridOn);
        log(`XML ‡§∏‡•á ‡§ó‡•ç‡§∞‡§ø‡§° ‡§∏‡•á‡§ü: ${gridOn ? 'On' : 'Off'}`);
    }

    if (restartRequired) {
        startCamera().then(() => applyDelayedSettings(zoom));
    } else {
        applyDelayedSettings(zoom);
    }
  };
  
  const applyDelayedSettings = (zoom) => {
      // Zoom needs to be applied after the camera stream is fully active
      setTimeout(() => {
          if (zoom && track && track.getCapabilities().zoom) {
              const zoomValue = parseFloat(zoom);
              if (zoomValue >= rngZoom.min && zoomValue <= rngZoom.max) {
                  rngZoom.value = zoomValue;
                  setZoom(zoomValue);
              }
          }
      }, 500); // 500ms delay to ensure track is ready
  }

  // Gallery
  const addToGallery = (el, filename, blob) => {
    const thumb = document.createElement('div');
    thumb.className = 'thumb';
    const actions = document.createElement('div');
    actions.className = 'actions';
    const dl = document.createElement('a');
    dl.href = el.src; dl.download = filename; dl.textContent = 'üì•'; dl.title = '‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°';
    actions.appendChild(dl);

    if (navigator.share) {
        const shareBtn = document.createElement('button');
        shareBtn.textContent = 'üì§'; shareBtn.title = '‡§∂‡•á‡§Ø‡§∞';
        shareBtn.onclick = () => shareMedia(filename, blob);
        actions.appendChild(shareBtn);
    }
    
    thumb.appendChild(el);
    thumb.appendChild(actions);
    gallery.prepend(thumb);
  };
  
  const shareMedia = async (filename, blob) => {
      try {
          const file = new File([blob], filename, { type: blob.type });
          await navigator.share({ files: [file], title: filename });
          log('‚úÖ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∂‡•á‡§Ø‡§∞ ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§');
      } catch(e) { if(e.name !== 'AbortError') error(e); }
  };
  
  // Event Listeners
  btnStart.onclick = startCamera;
  btnStop.onclick = stopCamera;
  btnFlip.onclick = () => { usingFront = !usingFront; startCamera(); };
  btnTorch.onclick = toggleTorch;
  btnSnap.onclick = snap;
  btnRec.onclick = toggleRecord;
  btnGrid.onclick = () => grid.classList.toggle('on');
  btnClear.onclick = () => { gallery.innerHTML = ''; log('‡§ó‡•à‡§≤‡§∞‡•Ä ‡§∏‡§æ‡§´‡§º ‡§π‡•ã ‡§ó‡§à‡•§') };
  btnQR.onclick = toggleQRScan;
  rngZoom.oninput = e => setZoom(e.target.value);
  selRes.onchange = startCamera;
  btnUploadXml.onclick = () => xmlUpload.click();
  xmlUpload.onchange = handleXmlUpload;

  // Pinch to Zoom
  let lastDist = 0;
  const dist = (a, b) => Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
  stage.addEventListener('touchstart', e => { if (e.touches.length === 2) lastDist = dist(e.touches[0], e.touches[1]); }, { passive: true });
  stage.addEventListener('touchmove', e => {
    if (e.touches.length === 2 && track && track.getCapabilities().zoom) {
        const d = dist(e.touches[0], e.touches[1]);
        const delta = (d - lastDist) / 200;
        const cur = Number(rngZoom.value);
        rngZoom.value = Math.min(rngZoom.max, Math.max(rngZoom.min, cur + delta));
        setZoom(rngZoom.value);
        lastDist = d;
    }
  }, { passive: true });
  
})();
</script>
</body>
</html>